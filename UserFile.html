<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TypeSynth ‚Äî Keystroke to Sound</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#121925; --muted:#9fb3c8; --text:#e8f0fe; --accent:#6ee7ff; --accent2:#a78bfa;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0f14 0%,#0e1420 100%);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Inter,Arial}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    .grid{display:grid;grid-template-columns:1fr 380px;gap:16px}
    .card{background:var(--card);border:1px solid #1f2a3a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    header.card{display:flex;align-items:center;justify-content:space-between;padding:16px 18px}
    header h1{font-size:20px;margin:0}
    .pill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid #2a3650;color:#cde3ff;background:#0f1624}
    .editor{padding:0}
    textarea{width:100%;height:360px;background:transparent;color:var(--text);border:0;resize:vertical;outline:0;font:15px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;padding:18px;border-radius:16px}
    .sidebar{padding:14px}
    .row{display:flex;gap:10px;align-items:center;margin:10px 0}
    .row label{font-size:13px;color:var(--muted);min-width:138px}
    input[type="range"]{width:100%}
    select,button,input[type="checkbox"]{background:#0f1624;color:#cde3ff;border:1px solid #2a3650;border-radius:10px;padding:8px 10px;font-size:14px}
    button{cursor:pointer}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap}
    .tiny{font-size:12px;color:#8ea4bf}
    .stat{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .badge{border:1px solid #2a3650;border-radius:8px;padding:4px 8px;font-size:12px;color:#b9c9de}
    .footer{padding:12px 16px;color:#8ea4bf;border-top:1px solid #1f2a3a}
    .section-title{font-size:13px;color:#b9c9de;margin:14px 0 6px}
    .mode{padding:10px 14px;border-radius:12px;background:#0e1420;border:1px dashed #2a3650}
    .progress{height:6px;background:#0f1624;border-radius:99px;overflow:hidden}
    .progress>div{height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent2));}
    .kbd{padding:2px 6px;border:1px solid #2a3650;border-radius:6px;background:#0f1624;color:#cde3ff;font-size:12px}
    .preset-row{display:flex;gap:8px;flex-wrap:wrap}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>TypeSynth <span class="pill">keystrokes ‚Üí music</span></h1>
      <div class="toolbar">
        <button id="btnStart">üîä Start Audio</button>
        <button id="btnClear">üßπ Clear</button>
        <button id="btnPlay">‚ñ∂Ô∏è Playback</button>
        <button id="btnStop">‚èπ Stop</button>
        <button id="btnExportAudio">üíæ Export Audio (WEBM)</button>
        <button id="btnExportWAV">üìÄ Export WAV (offline)</button>
        <button id="btnExportMIDI">üéº Export MIDI</button>
        <button id="btnPopout">‚ÜóÔ∏è Open in New Tab</button>
      </div>
    </header>

    <div class="grid">
      <section class="card editor">
        <textarea id="text" placeholder="Type here‚Ä¶ formal email, love note, or an angry letter ‚Äî each will sound different.
Hotkeys: 
‚Ä¢ Ctrl/Cmd+M toggle Live Mode 
‚Ä¢ Ctrl/Cmd+K toggle Compose/Record 
‚Ä¢ Ctrl/Cmd+P playback
"></textarea>
        <div class="footer">
          <span class="tiny">Numbers = bass ‚Ä¢ brackets = sweeps ‚Ä¢ punctuation = drums ‚Ä¢ vowels can trigger chords (toggle in sidebar). Adaptive mode morphs sound to your typing style.</span>
          <div class="stat" id="stats"></div>
        </div>
      </section>

      <aside class="card sidebar">
        <div class="section-title">Modes</div>
        <div class="mode">
          <div class="row"><label>Live Mode</label><input id="liveMode" type="checkbox" checked /></div>
          <div class="row"><label>Compose/Record</label><input id="composeMode" type="checkbox" /></div>
          <div class="row"><label>Quantize playback</label>
            <select id="quantize">
              <option value="0">off</option>
              <option value="0.0625">1/16</option>
              <option value="0.125">1/8</option>
              <option value="0.25">1/4</option>
            </select>
          </div>
          <div class="row"><label>Tempo (BPM)</label><input id="bpm" type="range" min="60" max="180" value="110" /></div>
          <div class="progress"><div id="prog"></div></div>
        </div>

        <div class="section-title">Presets (one‚Äëtap moods)</div>
        <div class="preset-row">
          <button class="preset" data-preset="formal">Formal</button>
          <button class="preset" data-preset="love">Love</button>
          <button class="preset" data-preset="angry">Angry</button>
          <button class="preset" data-preset="neutral">Neutral</button>
        </div>

        <div class="section-title">Chord Mode</div>
        <div class="row">
          <label>Chord Mode</label>
          <select id="chordMode">
            <option value="off">Off</option>
            <option value="triad">Triads</option>
            <option value="seventh">Sevenths</option>
          </select>
        </div>
        <div class="row">
          <label>Chord Trigger</label>
          <select id="chordTrigger">
            <option value="vowels">Vowels only</option>
            <option value="all">All letters</option>
          </select>
        </div>
        <div class="row"><label>Voicing</label>
          <select id="voicing">
            <option value="close">Close</option>
            <option value="open">Open</option>
          </select>
        </div>

        <div class="section-title">Synth</div>
        <div class="row"><label>Scale</label>
          <select id="scale">
            <option value="major">Major</option>
            <option value="minor">Minor</option>
            <option value="pentatonic">Pentatonic</option>
            <option value="chromatic">Chromatic</option>
          </select>
        </div>
        <div class="row"><label>Root</label>
          <select id="root"></select>
        </div>
        <div class="row"><label>Oscillator</label>
          <select id="osc">
            <option>sine</option>
            <option>triangle</option>
            <option>sawtooth</option>
            <option>square</option>
          </select>
        </div>
        <div class="row"><label>Attack</label><input id="attack" type="range" min="0" max="0.4" step="0.01" value="0.01" /></div>
        <div class="row"><label>Release</label><input id="release" type="range" min="0.05" max="1.5" step="0.01" value="0.25" /></div>
        <div class="row"><label>Filter</label><input id="cutoff" type="range" min="200" max="8000" step="50" value="2200" /></div>
        <div class="row"><label>Delay (ms)</label><input id="delay" type="range" min="0" max="600" step="10" value="120" /></div>
        <div class="row"><label>Drive</label><input id="drive" type="range" min="0" max="1" step="0.01" value="0.1" /></div>
        <div class="row"><label>Master Vol</label><input id="master" type="range" min="0" max="1" step="0.01" value="0.6" /></div>

        <div class="section-title">Adaptive Profile</div>
        <div class="row"><label>Adaptive mode</label><input id="adaptive" type="checkbox" /></div>
        <div class="tiny">Learns from your typing speed, CAPS, and punctuation. Faster + more CAPS ‚Üí brighter & more drive; slower + soft punctuation ‚Üí longer release & delay.</div>

        <div class="section-title">MIDI (optional)</div>
        <div class="row"><button id="btnMIDI">Enable WebMIDI</button></div>
        <div class="row"><label>Output</label><select id="midiOut"></select></div>

        <div class="section-title">Tips</div>
        <div class="tiny">
          ‚Ä¢ Punctuation plays drums. <span class="kbd">.</span>=kick <span class="kbd">!</span>=snare <span class="kbd">?</span>=hat<br/>
          ‚Ä¢ Numbers = bass notes; brackets = sweeps/risers; Backspace = down-chirp.<br/>
          ‚Ä¢ Turn on <b>Adaptive</b> to let the synth react to your style.
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  // ---------- Audio Graph ----------
  let ctx, master, filter, delay, delayGain, driveNode, streamDest, mediaRec;
  let lastTime = 0;
  let isPlayingBack = false, playbackStart = 0, playbackTimer = null;
  const recorded = []; // {t, key, upper}

  const A4 = 440;
  const midiToFreq = m => A4 * Math.pow(2, (m-69)/12);
  const roots = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const rootSel = document.getElementById('root');
  roots.forEach((r,i)=>{const o=document.createElement('option');o.value=i;o.textContent=r;o.selected=(i===0);rootSel.appendChild(o)});

  const scales = {
    major:[0,2,4,5,7,9,11],
    minor:[0,2,3,5,7,8,10],
    pentatonic:[0,2,4,7,9],
    chromatic:[0,1,2,3,4,5,6,7,8,9,10,11]
  };

  function initAudio(){
    if(ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    master = ctx.createGain(); master.gain.value = +document.getElementById('master').value;
    filter = ctx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value = +document.getElementById('cutoff').value;
    delay = ctx.createDelay(1.0); delay.delayTime.value = +document.getElementById('delay').value/1000;
    delayGain = ctx.createGain(); delayGain.gain.value = 0.22;

    // waveshaper for drive
    driveNode = ctx.createWaveShaper();
    function makeCurve(amount){
      const n=1024, curve=new Float32Array(n); const k = amount*100+1;
      for(let i=0;i<n;i++){ const x=i*2/n-1; curve[i]=(1+k)*x/(1+k*Math.abs(x)); }
      return curve;
    }
    driveNode.curve = makeCurve(+document.getElementById('drive').value);

    // Create a tap for MediaRecorder capture
    streamDest = ctx.createMediaStreamDestination();

    // connect graph: (voices) -> filter -> drive -> master -> destination & recording
    master.connect(ctx.destination);
    master.connect(streamDest);

    filter.connect(driveNode); driveNode.connect(master);
    // delay send/return
    const send = ctx.createGain(); send.gain.value = 0.25; send.connect(delay); delay.connect(delayGain); delayGain.connect(filter);
    // mix bus for voices
    const mix = ctx.createGain(); mix.connect(filter); // voices connect to mix + send
    window.__TypeSynthBus = {ctx, mix, send, makeCurve};
  }

  class Voice {
    constructor(freq, velocity, oscType, context=ctx){
      this.ctx = context;
      this.g = context.createGain();
      this.o = context.createOscillator();
      this.o.type = oscType;
      this.o.frequency.value = freq;
      this.g.gain.value = 0;
      this.o.connect(this.g);
      this.g.connect(window.__TypeSynthBus.mix);
      this.g.connect(window.__TypeSynthBus.send);
      this.o.start();
    }
    envOn(a, peak){ const t=(this.ctx||ctx).currentTime; this.gainCancel(); this.g.gain.linearRampToValueAtTime(peak, t+a); }
    envOff(r){ const t=(this.ctx||ctx).currentTime; this.gainCancel(); this.g.gain.linearRampToValueAtTime(0.0001, t+r); setTimeout(()=>this.stop(), r*1000+50); }
    gainCancel(){ try{ this.g.gain.cancelScheduledValues((this.ctx||ctx).currentTime); }catch(_){} }
    stop(){ try{this.o.stop();}catch(_){ } try{this.o.disconnect(); this.g.disconnect();}catch(_){}}
  }

  function setParamLinks(){
    document.getElementById('master').addEventListener('input', e=> master && (master.gain.value=+e.target.value));
    document.getElementById('cutoff').addEventListener('input', e=> filter && (filter.frequency.value=+e.target.value));
    document.getElementById('delay').addEventListener('input', e=> delay && (delay.delayTime.value=+e.target.value/1000));
    document.getElementById('drive').addEventListener('input', e=> driveNode && (driveNode.curve=window.__TypeSynthBus.makeCurve(+e.target.value)));
  }

  // ---------- Mapping ----------
  const letterRegex = /^[a-zA-Z]$/;
  const numberRegex = /^[0-9]$/;
  const vowels = new Set(['a','e','i','o','u','A','E','I','O','U','y','Y']);
  const drums = {
    kick(context=ctx){
      const o = context.createOscillator(); const g = context.createGain();
      o.type='sine'; o.frequency.setValueAtTime(140,context.currentTime); o.frequency.exponentialRampToValueAtTime(40, context.currentTime+0.15);
      g.gain.setValueAtTime(0.9, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.2);
      o.connect(g); g.connect(filter); o.start(); try{o.stop(context.currentTime+0.21);}catch(_){ }
    },
    snare(context=ctx){
      const noise = context.createBufferSource();
      const buffer = context.createBuffer(1, context.sampleRate*0.2, context.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*Math.pow(1-i/data.length, 2);
      noise.buffer=buffer;
      const g=context.createGain(); g.gain.setValueAtTime(0.6, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.18);
      const hp=context.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200;
      noise.connect(hp); hp.connect(g); g.connect(filter); noise.start();
    },
    hat(context=ctx){
      const noise = context.createBufferSource();
      const buffer = context.createBuffer(1, context.sampleRate*0.05, context.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
      noise.buffer=buffer;
      const g=context.createGain(); g.gain.setValueAtTime(0.35, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.05);
      const hp=context.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
      noise.connect(hp); hp.connect(g); g.connect(filter); noise.start();
    }
  };

  function keyToMidi(key){
    const root = +document.getElementById('root').value; // 0=C
    const scaleName = document.getElementById('scale').value;
    const intervals = scales[scaleName];
    const base = 60 + root; // around middle C
    const idx = (key.toLowerCase().charCodeAt(0) - 97); // a-z ‚Üí 0..25
    if(isNaN(idx) || idx < 0 || idx > 25) return 60;
    const degree = idx % intervals.length; const octave = Math.floor(idx / intervals.length);
    return base + intervals[degree] + 12*octave; // walks up octaves across alphabet
  }

  function numberToMidi(num){
    const base = 36 + (+document.getElementById('root').value);
    const scaleName = document.getElementById('scale').value; const intervals = scales[scaleName];
    const degree = num % intervals.length; const octave = Math.floor(num / intervals.length);
    return base + intervals[degree] + 12*octave;
  }

  function sweep(type='up', context=ctx){
    const o = context.createOscillator(); const g = context.createGain(); const f = context.createBiquadFilter();
    o.type='sawtooth'; g.gain.setValueAtTime(0.2, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.6);
    f.type='bandpass'; f.frequency.value= type==='up'? 400 : 2000;
    o.frequency.setValueAtTime(type==='up'? 120 : 1800, context.currentTime);
    o.frequency.exponentialRampToValueAtTime(type==='up'? 1600 : 100, context.currentTime+0.5);
    o.connect(f); f.connect(g); g.connect(filter); o.start(); try{o.stop(context.currentTime+0.55);}catch(_){ }
  }

  function chordIntervals(scaleName, mode){
    if(mode==='seventh') return (scaleName==='minor')? [0,3,7,10] : [0,4,7,11];
    if(mode==='triad') return (scaleName==='minor')? [0,3,7] : [0,4,7];
    return [0];
  }

  function playChordFromMidi(midi, upper, intensity, context=ctx){
    const scaleName = document.getElementById('scale').value;
    const mode = document.getElementById('chordMode').value;
    const voicing = document.getElementById('voicing').value;
    const intervals = chordIntervals(scaleName, mode);
    const spread = (voicing==='open')? [0, 7, 12, 19] : [0, 4, 7, 11]; // rough open/close mapping
    const toPlay = [];
    intervals.forEach((iv, i)=>{ const plus = (voicing==='open' && i>0)? spread[i] : iv; toPlay.push(midi + plus); });
    const atk = +document.getElementById('attack').value, rel = +document.getElementById('release').value;
    const oscType = document.getElementById('osc').value;
    toPlay.forEach((m,i)=>{
      const v = new Voice(midiToFreq(m), intensity, oscType, context);
      const amp = Math.min(1, 0.2 + intensity*0.8) * (i===0? 1.0 : 0.66);
      v.envOn(atk*(upper?1.2:1.0), amp);
      v.envOff(rel*(upper?1.1:1.0));
    });
  }

  function playLetter(key, upper, intensity){
    const midi = keyToMidi(key);
    const oscType = document.getElementById('osc').value;
    const mode = document.getElementById('chordMode').value;
    const trigger = document.getElementById('chordTrigger').value;
    const atk = +document.getElementById('attack').value;
    const rel = +document.getElementById('release').value;

    const shouldChord = (mode!=='off') && ((trigger==='all') || vowels.has(key));
    if(shouldChord){
      playChordFromMidi(midi, upper, intensity);
      return;
    }

    const v = new Voice(midiToFreq(midi), intensity, oscType);
    const amp = Math.min(1, 0.2 + intensity*0.8) * (upper? 1.05:1.0);
    v.envOn(atk*(upper?1.3:1.0), amp);
    v.envOff(rel*(upper?1.15:1.0));
  }

  function playNumber(n){
    const midi = numberToMidi(parseInt(n,10));
    const v = new Voice(midiToFreq(midi), 0.7, 'sine');
    v.envOn(0.005, 0.35); v.envOff(0.25);
  }

  function playPunctuation(char){
    if(char === '.') drums.kick();
    else if(char === '!') drums.snare();
    else if(char === '?') drums.hat();
  }

  function playBracket(ch){
    if('([{<'.includes(ch)) sweep('up');
    else if(')]}>'.includes(ch)) sweep('down');
  }

  // ---------- Keystroke Handler + Adaptive ----------
  const stats = document.getElementById('stats');
  function setStat(k,v){
    let el = document.querySelector(`[data-k='${k}']`);
    if(!el){ el=document.createElement('span'); el.className='badge'; el.dataset.k=k; stats.appendChild(el);} 
    el.textContent = `${k}: ${v}`;
  }

  const meter = { times:[], caps:0, punct:0 };
  function updateAdaptive(dt, upper, key){
    const adapt = document.getElementById('adaptive').checked; if(!adapt||!ctx) return;
    const now = performance.now();
    meter.times.push(now);
    if(upper) meter.caps++;
    if(['.','!','?'].includes(key)) meter.punct++;
    // keep last ~10s
    while(meter.times.length && now - meter.times[0] > 10000) meter.times.shift();
    const span = meter.times.length? (meter.times[meter.times.length-1]-meter.times[0]) : 1;
    const kps = meter.times.length / (span/1000); // keys per second
    const capsRatio = Math.min(1, meter.caps / Math.max(1, meter.times.length));
    const punctRatio = Math.min(1, meter.punct / Math.max(1, meter.times.length));

    // Map to params
    const tgtCut = 1200 + Math.min(1.0, kps/8)*4000; // 0..8 kps
    const tgtDrive = Math.min(0.6, 0.05 + capsRatio*0.6 + punctRatio*0.3);
    const tgtDelay = 40 + (1-Math.min(1,kps/8))*300; // slower ‚Üí more delay
    const tgtRel = 0.15 + (1-Math.min(1,kps/8))*0.9; // slower ‚Üí longer tail

    document.getElementById('cutoff').value = Math.round(tgtCut);
    document.getElementById('drive').value = tgtDrive.toFixed(2);
    document.getElementById('delay').value = Math.round(tgtDelay);
    document.getElementById('release').value = tgtRel.toFixed(2);

    // apply immediately
    filter.frequency.setTargetAtTime(tgtCut, ctx.currentTime, 0.05);
    delay.delayTime.setTargetAtTime(tgtDelay/1000, ctx.currentTime, 0.05);
    driveNode.curve = window.__TypeSynthBus.makeCurve(tgtDrive);
  }

  function handleKey(e){
    if(!ctx) return;
    // Hotkeys
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='m'){ e.preventDefault(); liveMode.checked=!liveMode.checked; return; }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='k'){ e.preventDefault(); composeMode.checked=!composeMode.checked; return; }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='p'){ e.preventDefault(); startPlayback(); return; }

    const now = performance.now();
    const dt = lastTime ? Math.max(1, now - lastTime) : 300;
    lastTime = now;

    const intensity = Math.max(0.05, Math.min(1, 240/dt));

    if(filter){ const base = +document.getElementById('cutoff').value; filter.frequency.setTargetAtTime(base + intensity*3000, ctx.currentTime, 0.03); }

    const upper = (e.key.length===1 && e.key === e.key.toUpperCase() && /[A-Z]/.test(e.key));
    const live = document.getElementById('liveMode').checked;

    if(letterRegex.test(e.key)){
      if(live) playLetter(e.key, upper, intensity);
      recordEvent(e.key, upper);
    } else if(['.','!','?'].includes(e.key)){
      if(live) playPunctuation(e.key);
      recordEvent(e.key, false);
    } else if(numberRegex.test(e.key)){
      if(live) playNumber(e.key);
      recordEvent('#'+e.key, false);
    } else if('()[]{}<>'.includes(e.key)){
      if(live) playBracket(e.key);
      recordEvent('br:'+e.key, false);
    } else if(e.key==='Backspace'){
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type='triangle'; o.frequency.setValueAtTime(320, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(120, ctx.currentTime+0.08);
      g.gain.setValueAtTime(0.25, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.1);
      o.connect(g); g.connect(filter); o.start(); try{o.stop(ctx.currentTime+0.11);}catch(_){ }
      recordEvent('<bk>', false);
    }

    setStat('dt(ms)', dt.toFixed(0));
    setStat('intensity', intensity.toFixed(2));
    setStat('caps', upper? 'YES':'no');

    updateAdaptive(dt, upper, e.key);
  }

  function recordEvent(key, upper){
    if(!document.getElementById('composeMode').checked) return;
    const t = performance.now();
    recorded.push({t, key, upper});
  }

  function startPlayback(){
    if(recorded.length===0 || !ctx) return 0;
    isPlayingBack = true; clearTimeout(playbackTimer);
    const q = parseFloat(document.getElementById('quantize').value);
    const bpm = +document.getElementById('bpm').value;
    const beatMs = 60000/bpm;
    const baseT = recorded[0].t;

    playbackStart = performance.now();
    const prog = document.getElementById('prog');
    let lastAt = 0;

    recorded.forEach((ev,i)=>{
      let at = ev.t - baseT;
      if(q>0){ const qms = q*beatMs; at = Math.round(at/qms)*qms; }
      lastAt = Math.max(lastAt, at);
      playbackTimer = setTimeout(()=>{
        if(!isPlayingBack) return;
        if(/^[a-zA-Z]$/.test(ev.key)) playLetter(ev.key, ev.upper, 0.7);
        else if(['.','!','?'].includes(ev.key)) playPunctuation(ev.key);
        else if(ev.key.startsWith('#')) playNumber(ev.key.slice(1));
        else if(ev.key.startsWith('br:')) playBracket(ev.key.slice(3));
        const p = Math.min(1, (performance.now()-playbackStart)/Math.max(1, lastAt));
        prog.style.width = (p*100).toFixed(1)+'%';
      }, at);
    });
    return lastAt + 400; // rough tail
  }

  function stopPlayback(){ isPlayingBack=false; clearTimeout(playbackTimer); document.getElementById('prog').style.width='0%'; }

  // ---------- WebMIDI (optional) ----------
  let midiAccess=null, midiOutput=null;
  document.getElementById('btnMIDI').addEventListener('click', async()=>{
    try{
      midiAccess = await navigator.requestMIDIAccess();
      const outSel = document.getElementById('midiOut');
      outSel.innerHTML='';
      midiAccess.outputs.forEach((out)=>{ const o=document.createElement('option'); o.value=out.id; o.textContent=out.name; outSel.appendChild(o); });
      outSel.addEventListener('change',e=>{ midiOutput = [...midiAccess.outputs.values()].find(o=>o.id===e.target.value); });
      midiOutput = midiAccess.outputs.values().next().value || null;
      if(midiOutput) outSel.value = midiOutput.id;
      alert('WebMIDI enabled. Selecting an output will mirror notes as MIDI.');
    }catch(err){ alert('WebMIDI not available in this browser or blocked by permissions.'); }
  });

  // mirror MIDI
  const _origPlayLetter = playLetter;
  playLetter = function(key, upper, intensity){
    const midi = keyToMidi(key); const vel = Math.round(20 + intensity*100);
    if(midiOutput){
      const mode = document.getElementById('chordMode').value;
      const trigger = document.getElementById('chordTrigger').value;
      const shouldChord = (mode!=='off') && ((trigger==='all') || vowels.has(key));
      if(shouldChord){
        const scaleName = document.getElementById('scale').value; const ivs = chordIntervals(scaleName, mode);
        ivs.forEach((iv,i)=>{ midiOutput.send([0x90, midi+iv, Math.max(20, vel-(i*15))]); setTimeout(()=>midiOutput && midiOutput.send([0x80, midi+iv, 0]), 140); });
      } else {
        midiOutput.send([0x90, midi, vel]); setTimeout(()=>midiOutput && midiOutput.send([0x80, midi, 0]), Math.max(80, 120 + (upper?40:0)));
      }
    }
    _origPlayLetter(key, upper, intensity);
  }

  // ---------- Presets ----------
  const presets = {
    neutral(){
      setVal('scale','major'); setVal('root','0'); setVal('osc','triangle');
      setRange('attack',0.02); setRange('release',0.35); setRange('cutoff',2200); setRange('delay',120); setRange('drive',0.1); setRange('master',0.6);
      setQuant(0.125); setBPM(110);
      applyNow();
    },
    formal(){
      setVal('scale','major'); setVal('root','0'); setVal('osc','sine');
      setRange('attack',0.03); setRange('release',0.6); setRange('cutoff',1800); setRange('delay',80); setRange('drive',0.02); setRange('master',0.55);
      setQuant(0.25); setBPM(96);
      applyNow();
    },
    love(){
      setVal('scale','pentatonic'); setVal('root','9'); setVal('osc','triangle');
      setRange('attack',0.06); setRange('release',1.0); setRange('cutoff',2600); setRange('delay',240); setRange('drive',0.08); setRange('master',0.6);
      setQuant(0.125); setBPM(88);
      applyNow();
    },
    angry(){
      setVal('scale','minor'); setVal('root','7'); setVal('osc','sawtooth');
      setRange('attack',0.005); setRange('release',0.18); setRange('cutoff',3800); setRange('delay',60); setRange('drive',0.35); setRange('master',0.7);
      setQuant(0.0625); setBPM(128);
      applyNow();
    }
  };
  function setVal(id,v){ const el=document.getElementById(id); el.value=v; el.dispatchEvent(new Event('input')); }
  function setRange(id,v){ const el=document.getElementById(id); el.value=v; el.dispatchEvent(new Event('input')); }
  function setQuant(v){ document.getElementById('quantize').value=String(v); }
  function setBPM(v){ document.getElementById('bpm').value=v; }
  function applyNow(){ if(!ctx) return; filter.frequency.value=+document.getElementById('cutoff').value; delay.delayTime.value=+document.getElementById('delay').value/1000; master.gain.value=+document.getElementById('master').value; }
  document.querySelectorAll('.preset').forEach(btn=> btn.addEventListener('click', e=>{ const p=e.target.dataset.preset; presets[p](); }));

  // ---------- Export: Audio (WEBM capture) ----------
  function exportAudio(){
    if(!ctx) return;
    if(recorded.length===0){ alert('Nothing recorded. Toggle Compose/Record, type, then try again.'); return; }
    try{
      mediaRec = new MediaRecorder(streamDest.stream);
    }catch(err){ alert('MediaRecorder not supported for audio on this browser. Try Chrome/Edge.'); return; }

    const chunks=[];
    mediaRec.ondataavailable = e=>{ if(e.data.size>0) chunks.push(e.data); };
    mediaRec.onstop = ()=>{
      const blob = new Blob(chunks, {type: 'audio/webm'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='typesynth_capture.webm'; a.click();
      URL.revokeObjectURL(url);
    };

    const dur = startPlayback();
    if(dur<=0){ alert('Nothing to play.'); return; }
    mediaRec.start();
    setTimeout(()=>{ mediaRec.stop(); stopPlayback(); }, Math.max(500, dur+200));
  }

  // ---------- Export: WAV (Offline render) ----------
  async function exportWAV(){
    if(recorded.length===0){ alert('Nothing recorded. Toggle Compose/Record, type, then try again.'); return; }
    const q = parseFloat(document.getElementById('quantize').value);
    const bpm = +document.getElementById('bpm').value;
    const beatMs = 60000/bpm; const baseT = recorded[0].t;

    // Build quantized event list
    const evs = [];
    recorded.forEach(ev=>{
      let at = ev.t - baseT; if(q>0){ const qms=q*beatMs; at = Math.round(at/qms)*qms; }
      evs.push({...ev, at});
    });
    evs.sort((a,b)=> a.at-b.at);
    const lastAt = evs.length? evs[evs.length-1].at : 0;

    const sr = 44100; const tail = 0.6; const duration = Math.ceil((lastAt/1000 + tail)*sr);
    const oc = new OfflineAudioContext(2, duration, sr);

    // build graph (offline)
    const oMaster = oc.createGain(); oMaster.gain.value = +document.getElementById('master').value;
    const oFilter = oc.createBiquadFilter(); oFilter.type='lowpass'; oFilter.frequency.value = +document.getElementById('cutoff').value;
    const oDelay = oc.createDelay(1.0); oDelay.delayTime.value = +document.getElementById('delay').value/1000;
    const oDelayGain = oc.createGain(); oDelayGain.gain.value = 0.22;
    const oDrive = oc.createWaveShaper();
    // small helper for waveshaper curve
    function makeCurve(amount){ const n=1024, c=new Float32Array(n); const k=amount*100+1; for(let i=0;i<n;i++){const x=i*2/n-1; c[i]=(1+k)*x/(1+k*Math.abs(x));} return c; }
    oDrive.curve = makeCurve(+document.getElementById('drive').value);

    oMaster.connect(oc.destination);
    oFilter.connect(oDrive); oDrive.connect(oMaster);
    const oSend = oc.createGain(); oSend.gain.value=0.25; oSend.connect(oDelay); oDelay.connect(oDelayGain); oDelayGain.connect(oFilter);
    const oMix = oc.createGain(); oMix.connect(oFilter);

    // local helpers (offline)
    function oVoice(freq){ const g=oc.createGain(); g.gain.value=0; const o=oc.createOscillator(); o.type=document.getElementById('osc').value; o.frequency.value=freq; o.connect(g); g.connect(oMix); g.connect(oSend); return {o,g}; }
    function oEnvOn(g, t, a, peak){ g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(peak, t+a); }
    function oEnvOff(g, t, r){ g.gain.linearRampToValueAtTime(0.0001, t+r); }
    function oKick(t){ const o=oc.createOscillator(), g=oc.createGain(); o.type='sine'; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(40, t+0.15); g.gain.setValueAtTime(0.9,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2); o.connect(g); g.connect(oFilter); o.start(t); o.stop(t+0.21); }
    function oSnare(t){ const n=oc.createBufferSource(); const b=oc.createBuffer(1, oc.sampleRate*0.2, oc.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length, 2); n.buffer=b; const g=oc.createGain(); g.gain.setValueAtTime(0.6,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); const hp=oc.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200; n.connect(hp); hp.connect(g); g.connect(oFilter); n.start(t); }
    function oHat(t){ const n=oc.createBufferSource(); const b=oc.createBuffer(1, oc.sampleRate*0.05, oc.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; n.buffer=b; const g=oc.createGain(); g.gain.setValueAtTime(0.35,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.05); const hp=oc.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; n.connect(hp); hp.connect(g); g.connect(oFilter); n.start(t); }

    function scheduleLetter(midi, upper, when){
      const atk = +document.getElementById('attack').value; const rel = +document.getElementById('release').value;
      const intensity = 0.7; // normalized for render
      const amp = Math.min(1, 0.2 + intensity*0.8) * (upper? 1.05:1.0);
      const mode = document.getElementById('chordMode').value;
      const trigger = document.getElementById('chordTrigger').value;
      const shouldChord = (mode!=='off') && (trigger==='all' || true); // for offline, treat letters as eligible; vowels handled by caller
      if(mode!=='off'){
        const scaleName = document.getElementById('scale').value; const ivs = chordIntervals(scaleName, mode);
        ivs.forEach((iv,i)=>{ const {o,g}=oVoice(midiToFreq(midi+iv)); o.start(when); oEnvOn(g, when, atk*(upper?1.2:1.0), i? amp*0.66: amp); oEnvOff(g, when, rel*(upper?1.1:1.0)); o.stop(when + Math.max(0.12, rel+0.2)); });
      } else {
        const {o,g}=oVoice(midiToFreq(midi)); o.start(when); oEnvOn(g, when, atk*(upper?1.3:1.0), amp); oEnvOff(g, when, rel*(upper?1.15:1.0)); o.stop(when + Math.max(0.12, rel+0.2));
      }
    }

    evs.forEach(ev=>{
      const t = ev.at/1000; // seconds
      if(/^[a-zA-Z]$/.test(ev.key)){
        const isVowel = vowels.has(ev.key);
        const chordMode = document.getElementById('chordMode').value;
        const trig = document.getElementById('chordTrigger').value;
        const allow = chordMode==='off' || (trig==='all' || isVowel);
        const midi = keyToMidi(ev.key);
        if(allow) scheduleLetter(midi, ev.upper, oc.currentTime + t);
      } else if(['.','!','?'].includes(ev.key)){
        if(ev.key==='.') oKick(oc.currentTime + t);
        else if(ev.key==='!') oSnare(oc.currentTime + t);
        else oHat(oc.currentTime + t);
      } else if(ev.key.startsWith('#')){
        const midi = numberToMidi(parseInt(ev.key.slice(1),10));
        scheduleLetter(midi, false, oc.currentTime + t);
      } else if(ev.key.startsWith('br:')){
        // Optional: light sweep for brackets
        const up = '([{<'.includes(ev.key.slice(3));
        // approximate with filter sweeps
        const f0 = oFilter.frequency.value; oFilter.frequency.setValueAtTime(up? 400 : 1800, oc.currentTime+t); oFilter.frequency.linearRampToValueAtTime(up? 1600: 300, oc.currentTime+t+0.5); oFilter.frequency.setValueAtTime(f0, oc.currentTime+t+0.6);
      }
    });

    const rendered = await oc.startRendering();

    // Convert to WAV (16-bit PCM)
    function bufferToWav(buffer){
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44; // bytes
      const ab = new ArrayBuffer(length);
      const view = new DataView(ab);
      let offset = 0;
      function writeStr(s){ for(let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); }
      function write16(v){ view.setUint16(offset, v, true); offset+=2; }
      function write32(v){ view.setUint32(offset, v, true); offset+=4; }

      writeStr('RIFF'); write32(length-8); writeStr('WAVE');
      writeStr('fmt '); write32(16); write16(1); write16(numOfChan); write32(buffer.sampleRate); write32(buffer.sampleRate*numOfChan*2); write16(numOfChan*2); write16(16);
      writeStr('data'); write32(length-44);

      const channels=[]; for(let i=0;i<numOfChan;i++) channels.push(buffer.getChannelData(i));
      const interleaved = new Float32Array(buffer.length * numOfChan);
      for(let i=0, idx=0;i<buffer.length;i++) for(let ch=0; ch<numOfChan; ch++) interleaved[idx++] = channels[ch][i];
      // clamp & convert
      for(let i=0; i<interleaved.length; i++){ let s = Math.max(-1, Math.min(1, interleaved[i])); view.setInt16(offset, s<0? s*0x8000 : s*0x7FFF, true); offset+=2; }
      return new Blob([ab], {type:'audio/wav'});
    }

    const wav = bufferToWav(rendered);
    const url = URL.createObjectURL(wav);
    const a = document.createElement('a'); a.href=url; a.download='typesynth_offline.wav'; a.click(); URL.revokeObjectURL(url);
  }

  // ---------- Export: MIDI (SMF Type 0) ----------
  function exportMIDI(){
    if(recorded.length===0){ alert('Nothing recorded. Toggle Compose/Record, type, then try again.'); return; }
    const bpm = +document.getElementById('bpm').value; const q = parseFloat(document.getElementById('quantize').value);
    const ppq = 480; // ticks per quarter
    const beatMs = 60000/bpm;
    const baseT = recorded[0].t;

    function vtime(ms){ return Math.round((ms/beatMs)*ppq); }
    function vlq(n){ const bytes=[]; let buffer=n & 0x7F; while((n >>=7)){ buffer <<=8; buffer |= ((n & 0x7F) | 0x80); } while(true){ bytes.push(buffer & 0xFF); if(buffer & 0x80) buffer >>=8; else break; } return bytes; }

    const evs = [];
    recorded.forEach(ev=>{
      let at = ev.t - baseT; if(q>0){ const qms=q*beatMs; at = Math.round(at/qms)*qms; }
      if(/^[a-zA-Z]$/.test(ev.key)){
        const midi = keyToMidi(ev.key);
        // if chord mode, write chord
        const scaleName = document.getElementById('scale').value; const mode = document.getElementById('chordMode').value; const trig=document.getElementById('chordTrigger').value; const isV=vowels.has(ev.key);
        const ivs = (mode==='off' || (trig==='vowels' && !isV))? [0] : chordIntervals(scaleName, mode);
        ivs.forEach((iv,i)=> evs.push({at, on:[0x90, midi+iv, 96-i*12], off:[0x80, midi+iv, 0], len: 160}));
      } else if(['.','!','?'].includes(ev.key)){
        const map = {'.':36,'!':38,'?':42}; const n = map[ev.key];
        evs.push({at, on:[0x99, n, 100], off:[0x89, n, 0], len: 80});
      } else if(ev.key.startsWith('#')){
        const midi = numberToMidi(parseInt(ev.key.slice(1),10));
        evs.push({at, on:[0x90, midi, 90], off:[0x80, midi, 0], len: 220});
      }
    });
    evs.sort((a,b)=> a.at-b.at);

    const track=[]; let lastTick=0;
    const mpq = Math.round(60000000/bpm);
    track.push(...vlq(0), 0xFF, 0x51, 0x03, (mpq>>16)&255, (mpq>>8)&255, mpq&255);

    evs.forEach(e=>{
      const start = vtime(e.at); const deltaOn = start - lastTick; lastTick = start;
      track.push(...vlq(deltaOn), ...e.on);
      const end = vtime(e.at + e.len); const deltaOff = end - lastTick; lastTick = end;
      track.push(...vlq(deltaOff), ...e.off);
    });
    track.push(...vlq(0), 0xFF, 0x2F, 0x00);

    function str2bytes(s){ return [...s].map(c=>c.charCodeAt(0)); }
    const header = [ ...str2bytes('MThd'), 0x00,0x00,0x00,0x06, 0x00,0x00, 0x01,0xE0 ]; // PPQ=480
    const trkHeader = [ ...str2bytes('MTrk')];
    const len = track.length; const lenBytes = [(len>>>24)&255,(len>>>16)&255,(len>>>8)&255,(len)&255];
    const bytes = new Uint8Array([...header, ...trkHeader, ...lenBytes, ...track]);

    const blob = new Blob([bytes], {type:'audio/midi'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='typesynth_track.mid'; a.click(); URL.revokeObjectURL(url);
  }

  // ---------- Wire up UI ----------
  document.getElementById('btnStart').addEventListener('click', ()=>{ initAudio(); setParamLinks(); document.getElementById('text').focus(); });
  document.getElementById('btnClear').addEventListener('click', ()=>{ document.getElementById('text').value=''; recorded.length=0; });
  document.getElementById('btnPlay').addEventListener('click', startPlayback);
  document.getElementById('btnStop').addEventListener('click', stopPlayback);
  document.getElementById('btnExportAudio').addEventListener('click', exportAudio);
  document.getElementById('btnExportMIDI').addEventListener('click', exportMIDI);
  document.getElementById('btnExportWAV').addEventListener('click', exportWAV);
  document.getElementById('btnPopout').addEventListener('click', openStandalone);

  document.getElementById('text').addEventListener('keydown', (e)=>{
    if((e.ctrlKey||e.metaKey) && ['m','k','p'].includes(e.key.toLowerCase())) e.preventDefault();
  });
  document.getElementById('text').addEventListener('keyup', (e)=>{ if(!ctx) return; handleKey(e); });
})();
  function openStandalone(){
    // Serialize this document and open it as a standalone tab
    const html = '<!DOCTYPE html>' + document.documentElement.outerHTML;
    const blob = new Blob([html], {type: 'text/html'});
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank','noopener');
    setTimeout(()=> URL.revokeObjectURL(url), 60000);
  }
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TypeSynth ‚Äî Keystroke to Sound</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#121925; --muted:#9fb3c8; --text:#e8f0fe; --accent:#6ee7ff; --accent2:#a78bfa;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0f14 0%,#0e1420 100%);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Inter,Arial}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    .grid{display:grid;grid-template-columns:1fr 380px;gap:16px}
    .card{background:var(--card);border:1px solid #1f2a3a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    header.card{display:flex;align-items:center;justify-content:space-between;padding:16px 18px}
    header h1{font-size:20px;margin:0}
    .pill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid #2a3650;color:#cde3ff;background:#0f1624}
    .editor{padding:0}
    textarea{width:100%;height:360px;background:transparent;color:var(--text);border:0;resize:vertical;outline:0;font:15px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;padding:18px;border-radius:16px}
    .sidebar{padding:14px}
    .row{display:flex;gap:10px;align-items:center;margin:10px 0}
    .row label{font-size:13px;color:var(--muted);min-width:138px}
    input[type="range"]{width:100%}
    select,button,input[type="checkbox"]{background:#0f1624;color:#cde3ff;border:1px solid #2a3650;border-radius:10px;padding:8px 10px;font-size:14px}
    button{cursor:pointer}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap}
    .tiny{font-size:12px;color:#8ea4bf}
    .stat{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .badge{border:1px solid #2a3650;border-radius:8px;padding:4px 8px;font-size:12px;color:#b9c9de}
    .footer{padding:12px 16px;color:#8ea4bf;border-top:1px solid #1f2a3a}
    .section-title{font-size:13px;color:#b9c9de;margin:14px 0 6px}
    .mode{padding:10px 14px;border-radius:12px;background:#0e1420;border:1px dashed #2a3650}
    .progress{height:6px;background:#0f1624;border-radius:99px;overflow:hidden}
    .progress>div{height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent2));}
    .kbd{padding:2px 6px;border:1px solid #2a3650;border-radius:6px;background:#0f1624;color:#cde3ff;font-size:12px}
    .preset-row{display:flex;gap:8px;flex-wrap:wrap}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>TypeSynth <span class="pill">keystrokes ‚Üí music</span></h1>
      <div class="toolbar">
        <button id="btnStart">üîä Start Audio</button>
        <button id="btnClear">üßπ Clear</button>
        <button id="btnPlay">‚ñ∂Ô∏è Playback</button>
        <button id="btnStop">‚èπ Stop</button>
        <button id="btnExportAudio">üíæ Export Audio (WEBM)</button>
        <button id="btnExportWAV">üìÄ Export WAV (offline)</button>
        <button id="btnExportMIDI">üéº Export MIDI</button>
      </div>
    </header>

    <div class="grid">
      <section class="card editor">
        <textarea id="text" placeholder="Type here‚Ä¶ formal email, love note, or an angry letter ‚Äî each will sound different.
Hotkeys: 
‚Ä¢ Ctrl/Cmd+M toggle Live Mode 
‚Ä¢ Ctrl/Cmd+K toggle Compose/Record 
‚Ä¢ Ctrl/Cmd+P playback
"></textarea>
        <div class="footer">
          <span class="tiny">Numbers = bass ‚Ä¢ brackets = sweeps ‚Ä¢ punctuation = drums ‚Ä¢ vowels can trigger chords (toggle in sidebar). Adaptive mode morphs sound to your typing style.</span>
          <div class="stat" id="stats"></div>
        </div>
      </section>

      <aside class="card sidebar">
        <div class="section-title">Modes</div>
        <div class="mode">
          <div class="row"><label>Live Mode</label><input id="liveMode" type="checkbox" checked /></div>
          <div class="row"><label>Compose/Record</label><input id="composeMode" type="checkbox" /></div>
          <div class="row"><label>Quantize playback</label>
            <select id="quantize">
              <option value="0">off</option>
              <option value="0.0625">1/16</option>
              <option value="0.125">1/8</option>
              <option value="0.25">1/4</option>
            </select>
          </div>
          <div class="row"><label>Tempo (BPM)</label><input id="bpm" type="range" min="60" max="180" value="110" /></div>
          <div class="progress"><div id="prog"></div></div>
        </div>

        <div class="section-title">Presets (one‚Äëtap moods)</div>
        <div class="preset-row">
          <button class="preset" data-preset="formal">Formal</button>
          <button class="preset" data-preset="love">Love</button>
          <button class="preset" data-preset="angry">Angry</button>
          <button class="preset" data-preset="neutral">Neutral</button>
        </div>

        <div class="section-title">Chord Mode</div>
        <div class="row">
          <label>Chord Mode</label>
          <select id="chordMode">
            <option value="off">Off</option>
            <option value="triad">Triads</option>
            <option value="seventh">Sevenths</option>
          </select>
        </div>
        <div class="row">
          <label>Chord Trigger</label>
          <select id="chordTrigger">
            <option value="vowels">Vowels only</option>
            <option value="all">All letters</option>
          </select>
        </div>
        <div class="row"><label>Voicing</label>
          <select id="voicing">
            <option value="close">Close</option>
            <option value="open">Open</option>
          </select>
        </div>

        <div class="section-title">Synth</div>
        <div class="row"><label>Scale</label>
          <select id="scale">
            <option value="major">Major</option>
            <option value="minor">Minor</option>
            <option value="pentatonic">Pentatonic</option>
            <option value="chromatic">Chromatic</option>
          </select>
        </div>
        <div class="row"><label>Root</label>
          <select id="root"></select>
        </div>
        <div class="row"><label>Oscillator</label>
          <select id="osc">
            <option>sine</option>
            <option>triangle</option>
            <option>sawtooth</option>
            <option>square</option>
          </select>
        </div>
        <div class="row"><label>Attack</label><input id="attack" type="range" min="0" max="0.4" step="0.01" value="0.01" /></div>
        <div class="row"><label>Release</label><input id="release" type="range" min="0.05" max="1.5" step="0.01" value="0.25" /></div>
        <div class="row"><label>Filter</label><input id="cutoff" type="range" min="200" max="8000" step="50" value="2200" /></div>
        <div class="row"><label>Delay (ms)</label><input id="delay" type="range" min="0" max="600" step="10" value="120" /></div>
        <div class="row"><label>Drive</label><input id="drive" type="range" min="0" max="1" step="0.01" value="0.1" /></div>
        <div class="row"><label>Master Vol</label><input id="master" type="range" min="0" max="1" step="0.01" value="0.6" /></div>

        <div class="section-title">Adaptive Profile</div>
        <div class="row"><label>Adaptive mode</label><input id="adaptive" type="checkbox" /></div>
        <div class="tiny">Learns from your typing speed, CAPS, and punctuation. Faster + more CAPS ‚Üí brighter & more drive; slower + soft punctuation ‚Üí longer release & delay.</div>

        <div class="section-title">MIDI (optional)</div>
        <div class="row"><button id="btnMIDI">Enable WebMIDI</button></div>
        <div class="row"><label>Output</label><select id="midiOut"></select></div>

        <div class="section-title">Tips</div>
        <div class="tiny">
          ‚Ä¢ Punctuation plays drums. <span class="kbd">.</span>=kick <span class="kbd">!</span>=snare <span class="kbd">?</span>=hat<br/>
          ‚Ä¢ Numbers = bass notes; brackets = sweeps/risers; Backspace = down-chirp.<br/>
          ‚Ä¢ Turn on <b>Adaptive</b> to let the synth react to your style.
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  // ---------- Audio Graph ----------
  let ctx, master, filter, delay, delayGain, driveNode, streamDest, mediaRec;
  let lastTime = 0;
  let isPlayingBack = false, playbackStart = 0, playbackTimer = null;
  const recorded = []; // {t, key, upper}

  const A4 = 440;
  const midiToFreq = m => A4 * Math.pow(2, (m-69)/12);
  const roots = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const rootSel = document.getElementById('root');
  roots.forEach((r,i)=>{const o=document.createElement('option');o.value=i;o.textContent=r;o.selected=(i===0);rootSel.appendChild(o)});

  const scales = {
    major:[0,2,4,5,7,9,11],
    minor:[0,2,3,5,7,8,10],
    pentatonic:[0,2,4,7,9],
    chromatic:[0,1,2,3,4,5,6,7,8,9,10,11]
  };

  function initAudio(){
    if(ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    master = ctx.createGain(); master.gain.value = +document.getElementById('master').value;
    filter = ctx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value = +document.getElementById('cutoff').value;
    delay = ctx.createDelay(1.0); delay.delayTime.value = +document.getElementById('delay').value/1000;
    delayGain = ctx.createGain(); delayGain.gain.value = 0.22;

    // waveshaper for drive
    driveNode = ctx.createWaveShaper();
    function makeCurve(amount){
      const n=1024, curve=new Float32Array(n); const k = amount*100+1;
      for(let i=0;i<n;i++){ const x=i*2/n-1; curve[i]=(1+k)*x/(1+k*Math.abs(x)); }
      return curve;
    }
    driveNode.curve = makeCurve(+document.getElementById('drive').value);

    // Create a tap for MediaRecorder capture
    streamDest = ctx.createMediaStreamDestination();

    // connect graph: (voices) -> filter -> drive -> master -> destination & recording
    master.connect(ctx.destination);
    master.connect(streamDest);

    filter.connect(driveNode); driveNode.connect(master);
    // delay send/return
    const send = ctx.createGain(); send.gain.value = 0.25; send.connect(delay); delay.connect(delayGain); delayGain.connect(filter);
    // mix bus for voices
    const mix = ctx.createGain(); mix.connect(filter); // voices connect to mix + send
    window.__TypeSynthBus = {ctx, mix, send, makeCurve};
  }

  class Voice {
    constructor(freq, velocity, oscType, context=ctx){
      this.ctx = context;
      this.g = context.createGain();
      this.o = context.createOscillator();
      this.o.type = oscType;
      this.o.frequency.value = freq;
      this.g.gain.value = 0;
      this.o.connect(this.g);
      this.g.connect(window.__TypeSynthBus.mix);
      this.g.connect(window.__TypeSynthBus.send);
      this.o.start();
    }
    envOn(a, peak){ const t=(this.ctx||ctx).currentTime; this.gainCancel(); this.g.gain.linearRampToValueAtTime(peak, t+a); }
    envOff(r){ const t=(this.ctx||ctx).currentTime; this.gainCancel(); this.g.gain.linearRampToValueAtTime(0.0001, t+r); setTimeout(()=>this.stop(), r*1000+50); }
    gainCancel(){ try{ this.g.gain.cancelScheduledValues((this.ctx||ctx).currentTime); }catch(_){} }
    stop(){ try{this.o.stop();}catch(_){ } try{this.o.disconnect(); this.g.disconnect();}catch(_){}}
  }

  function setParamLinks(){
    document.getElementById('master').addEventListener('input', e=> master && (master.gain.value=+e.target.value));
    document.getElementById('cutoff').addEventListener('input', e=> filter && (filter.frequency.value=+e.target.value));
    document.getElementById('delay').addEventListener('input', e=> delay && (delay.delayTime.value=+e.target.value/1000));
    document.getElementById('drive').addEventListener('input', e=> driveNode && (driveNode.curve=window.__TypeSynthBus.makeCurve(+e.target.value)));
  }

  // ---------- Mapping ----------
  const letterRegex = /^[a-zA-Z]$/;
  const numberRegex = /^[0-9]$/;
  const vowels = new Set(['a','e','i','o','u','A','E','I','O','U','y','Y']);
  const drums = {
    kick(context=ctx){
      const o = context.createOscillator(); const g = context.createGain();
      o.type='sine'; o.frequency.setValueAtTime(140,context.currentTime); o.frequency.exponentialRampToValueAtTime(40, context.currentTime+0.15);
      g.gain.setValueAtTime(0.9, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.2);
      o.connect(g); g.connect(filter); o.start(); try{o.stop(context.currentTime+0.21);}catch(_){ }
    },
    snare(context=ctx){
      const noise = context.createBufferSource();
      const buffer = context.createBuffer(1, context.sampleRate*0.2, context.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*Math.pow(1-i/data.length, 2);
      noise.buffer=buffer;
      const g=context.createGain(); g.gain.setValueAtTime(0.6, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.18);
      const hp=context.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200;
      noise.connect(hp); hp.connect(g); g.connect(filter); noise.start();
    },
    hat(context=ctx){
      const noise = context.createBufferSource();
      const buffer = context.createBuffer(1, context.sampleRate*0.05, context.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
      noise.buffer=buffer;
      const g=context.createGain(); g.gain.setValueAtTime(0.35, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.05);
      const hp=context.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
      noise.connect(hp); hp.connect(g); g.connect(filter); noise.start();
    }
  };

  function keyToMidi(key){
    const root = +document.getElementById('root').value; // 0=C
    const scaleName = document.getElementById('scale').value;
    const intervals = scales[scaleName];
    const base = 60 + root; // around middle C
    const idx = (key.toLowerCase().charCodeAt(0) - 97); // a-z ‚Üí 0..25
    if(isNaN(idx) || idx < 0 || idx > 25) return 60;
    const degree = idx % intervals.length; const octave = Math.floor(idx / intervals.length);
    return base + intervals[degree] + 12*octave; // walks up octaves across alphabet
  }

  function numberToMidi(num){
    const base = 36 + (+document.getElementById('root').value);
    const scaleName = document.getElementById('scale').value; const intervals = scales[scaleName];
    const degree = num % intervals.length; const octave = Math.floor(num / intervals.length);
    return base + intervals[degree] + 12*octave;
  }

  function sweep(type='up', context=ctx){
    const o = context.createOscillator(); const g = context.createGain(); const f = context.createBiquadFilter();
    o.type='sawtooth'; g.gain.setValueAtTime(0.2, context.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, context.currentTime+0.6);
    f.type='bandpass'; f.frequency.value= type==='up'? 400 : 2000;
    o.frequency.setValueAtTime(type==='up'? 120 : 1800, context.currentTime);
    o.frequency.exponentialRampToValueAtTime(type==='up'? 1600 : 100, context.currentTime+0.5);
    o.connect(f); f.connect(g); g.connect(filter); o.start(); try{o.stop(context.currentTime+0.55);}catch(_){ }
  }

  function chordIntervals(scaleName, mode){
    if(mode==='seventh') return (scaleName==='minor')? [0,3,7,10] : [0,4,7,11];
    if(mode==='triad') return (scaleName==='minor')? [0,3,7] : [0,4,7];
    return [0];
  }

  function playChordFromMidi(midi, upper, intensity, context=ctx){
    const scaleName = document.getElementById('scale').value;
    const mode = document.getElementById('chordMode').value;
    const voicing = document.getElementById('voicing').value;
    const intervals = chordIntervals(scaleName, mode);
    const spread = (voicing==='open')? [0, 7, 12, 19] : [0, 4, 7, 11]; // rough open/close mapping
    const toPlay = [];
    intervals.forEach((iv, i)=>{ const plus = (voicing==='open' && i>0)? spread[i] : iv; toPlay.push(midi + plus); });
    const atk = +document.getElementById('attack').value, rel = +document.getElementById('release').value;
    const oscType = document.getElementById('osc').value;
    toPlay.forEach((m,i)=>{
      const v = new Voice(midiToFreq(m), intensity, oscType, context);
      const amp = Math.min(1, 0.2 + intensity*0.8) * (i===0? 1.0 : 0.66);
      v.envOn(atk*(upper?1.2:1.0), amp);
      v.envOff(rel*(upper?1.1:1.0));
    });
  }

  function playLetter(key, upper, intensity){
    const midi = keyToMidi(key);
    const oscType = document.getElementById('osc').value;
    const mode = document.getElementById('chordMode').value;
    const trigger = document.getElementById('chordTrigger').value;
    const atk = +document.getElementById('attack').value;
    const rel = +document.getElementById('release').value;

    const shouldChord = (mode!=='off') && ((trigger==='all') || vowels.has(key));
    if(shouldChord){
      playChordFromMidi(midi, upper, intensity);
      return;
    }

    const v = new Voice(midiToFreq(midi), intensity, oscType);
    const amp = Math.min(1, 0.2 + intensity*0.8) * (upper? 1.05:1.0);
    v.envOn(atk*(upper?1.3:1.0), amp);
    v.envOff(rel*(upper?1.15:1.0));
  }

  function playNumber(n){
    const midi = numberToMidi(parseInt(n,10));
    const v = new Voice(midiToFreq(midi), 0.7, 'sine');
    v.envOn(0.005, 0.35); v.envOff(0.25);
  }

  function playPunctuation(char){
    if(char === '.') drums.kick();
    else if(char === '!') drums.snare();
    else if(char === '?') drums.hat();
  }

  function playBracket(ch){
    if('([{<'.includes(ch)) sweep('up');
    else if(')]}>'.includes(ch)) sweep('down');
  }

  // ---------- Keystroke Handler + Adaptive ----------
  const stats = document.getElementById('stats');
  function setStat(k,v){
    let el = document.querySelector(`[data-k='${k}']`);
    if(!el){ el=document.createElement('span'); el.className='badge'; el.dataset.k=k; stats.appendChild(el);} 
    el.textContent = `${k}: ${v}`;
  }

  const meter = { times:[], caps:0, punct:0 };
  function updateAdaptive(dt, upper, key){
    const adapt = document.getElementById('adaptive').checked; if(!adapt||!ctx) return;
    const now = performance.now();
    meter.times.push(now);
    if(upper) meter.caps++;
    if(['.','!','?'].includes(key)) meter.punct++;
    // keep last ~10s
    while(meter.times.length && now - meter.times[0] > 10000) meter.times.shift();
    const span = meter.times.length? (meter.times[meter.times.length-1]-meter.times[0]) : 1;
    const kps = meter.times.length / (span/1000); // keys per second
    const capsRatio = Math.min(1, meter.caps / Math.max(1, meter.times.length));
    const punctRatio = Math.min(1, meter.punct / Math.max(1, meter.times.length));

    // Map to params
    const tgtCut = 1200 + Math.min(1.0, kps/8)*4000; // 0..8 kps
    const tgtDrive = Math.min(0.6, 0.05 + capsRatio*0.6 + punctRatio*0.3);
    const tgtDelay = 40 + (1-Math.min(1,kps/8))*300; // slower ‚Üí more delay
    const tgtRel = 0.15 + (1-Math.min(1,kps/8))*0.9; // slower ‚Üí longer tail

    document.getElementById('cutoff').value = Math.round(tgtCut);
    document.getElementById('drive').value = tgtDrive.toFixed(2);
    document.getElementById('delay').value = Math.round(tgtDelay);
    document.getElementById('release').value = tgtRel.toFixed(2);

    // apply immediately
    filter.frequency.setTargetAtTime(tgtCut, ctx.currentTime, 0.05);
    delay.delayTime.setTargetAtTime(tgtDelay/1000, ctx.currentTime, 0.05);
    driveNode.curve = window.__TypeSynthBus.makeCurve(tgtDrive);
  }

  function handleKey(e){
    if(!ctx) return;
    // Hotkeys
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='m'){ e.preventDefault(); liveMode.checked=!liveMode.checked; return; }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='k'){ e.preventDefault(); composeMode.checked=!composeMode.checked; return; }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='p'){ e.preventDefault(); startPlayback(); return; }

    const now = performance.now();
    const dt = lastTime ? Math.max(1, now - lastTime) : 300;
    lastTime = now;

    const intensity = Math.max(0.05, Math.min(1, 240/dt));

    if(filter){ const base = +document.getElementById('cutoff').value; filter.frequency.setTargetAtTime(base + intensity*3000, ctx.currentTime, 0.03); }

    const upper = (e.key.length===1 && e.key === e.key.toUpperCase() && /[A-Z]/.test(e.key));
    const live = document.getElementById('liveMode').checked;

    if(letterRegex.test(e.key)){
      if(live) playLetter(e.key, upper, intensity);
      recordEvent(e.key, upper);
    } else if(['.','!','?'].includes(e.key)){
      if(live) playPunctuation(e.key);
      recordEvent(e.key, false);
    } else if(numberRegex.test(e.key)){
      if(live) playNumber(e.key);
      recordEvent('#'+e.key, false);
    } else if('()[]{}<>'.includes(e.key)){
      if(live) playBracket(e.key);
      recordEvent('br:'+e.key, false);
    } else if(e.key==='Backspace'){
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type='triangle'; o.frequency.setValueAtTime(320, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(120, ctx.currentTime+0.08);
      g.gain.setValueAtTime(0.25, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.1);
      o.connect(g); g.connect(filter); o.start(); try{o.stop(ctx.currentTime+0.11);}catch(_){ }
      recordEvent('<bk>', false);
    }

    setStat('dt(ms)', dt.toFixed(0));
    setStat('intensity', intensity.toFixed(2));
    setStat('caps', upper? 'YES':'no');

    updateAdaptive(dt, upper, e.key);
  }

  function recordEvent(key, upper){
    if(!document.getElementById('composeMode').checked) return;
    const t = performance.now();
    recorded.push({t, key, upper});
  }

  function startPlayback(){
    if(recorded.length===0 || !ctx) return 0;
    isPlayingBack = true; clearTimeout(playbackTimer);
    const q = parseFloat(document.getElementById('quantize').value);
    const bpm = +document.getElementById('bpm').value;
    const beatMs = 60000/bpm;
    const baseT = recorded[0].t;

    playbackStart = performance.now();
    const prog = document.getElementById('prog');
    let lastAt = 0;

    recorded.forEach((ev,i)=>{
      let at = ev.t - baseT;
      if(q>0){ const qms = q*beatMs; at = Math.round(at/qms)*qms; }
      lastAt = Math.max(lastAt, at);
      playbackTimer = setTimeout(()=>{
        if(!isPlayingBack) return;
        if(/^[a-zA-Z]$/.test(ev.key)) playLetter(ev.key, ev.upper, 0.7);
        else if(['.','!','?'].includes(ev.key)) playPunctuation(ev.key);
        else if(ev.key.startsWith('#')) playNumber(ev.key.slice(1));
        else if(ev.key.startsWith('br:')) playBracket(ev.key.slice(3));
        const p = Math.min(1, (performance.now()-playbackStart)/Math.max(1, lastAt));
        prog.style.width = (p*100).toFixed(1)+'%';
      }, at);
    });
    return lastAt + 400; // rough tail
  }

  function stopPlayback(){ isPlayingBack=false; clearTimeout(playbackTimer); document.getElementById('prog').style.width='0%'; }

  // ---------- WebMIDI (optional) ----------
  let midiAccess=null, midiOutput=null;
  document.getElementById('btnMIDI').addEventListener('click', async()=>{
    try{
      midiAccess = await navigator.requestMIDIAccess();
      const outSel = document.getElementById('midiOut');
      outSel.innerHTML='';
      midiAccess.outputs.forEach((out)=>{ const o=document.createElement('option'); o.value=out.id; o.textContent=out.name; outSel.appendChild(o); });
      outSel.addEventListener('change',e=>{ midiOutput = [...midiAccess.outputs.values()].find(o=>o.id===e.target.value); });
      midiOutput = midiAccess.outputs.values().next().value || null;
      if(midiOutput) outSel.value = midiOutput.id;
      alert('WebMIDI enabled. Selecting an output will mirror notes as MIDI.');
    }catch(err){ alert('WebMIDI not available in this browser or blocked by permissions.'); }
  });

  // mirror MIDI
  const _origPlayLetter = playLetter;
  playLetter = function(key, upper, intensity){
    const midi = keyToMidi(key); const vel = Math.round(20 + intensity*100);
    if(midiOutput){
      const mode = document.getElementById('chordMode').value;
      const trigger = document.getElementById('chordTrigger').value;
      const shouldChord = (mode!=='off') && ((trigger==='all') || vowels.has(key));
      if(shouldChord){
        const scaleName = document.getElementById('scale').value; const ivs = chordIntervals(scaleName, mode);
        ivs.forEach((iv,i)=>{ midiOutput.send([0x90, midi+iv, Math.max(20, vel-(i*15))]); setTimeout(()=>midiOutput && midiOutput.send([0x80, midi+iv, 0]), 140); });
      } else {
        midiOutput.send([0x90, midi, vel]); setTimeout(()=>midiOutput && midiOutput.send([0x80, midi, 0]), Math.max(80, 120 + (upper?40:0)));
      }
    }
    _origPlayLetter(key, upper, intensity);
  }

  // ---------- Presets ----------
  const presets = {
    neutral(){
      setVal('scale','major'); setVal('root','0'); setVal('osc','triangle');
      setRange('attack',0.02); setRange('release',0.35); setRange('cutoff',2200); setRange('delay',120); setRange('drive',0.1); setRange('master',0.6);
      setQuant(0.125); setBPM(110);
      applyNow();
    },
    formal(){
      setVal('scale','major'); setVal('root','0'); setVal('osc','sine');
      setRange('attack',0.03); setRange('release',0.6); setRange('cutoff',1800); setRange('delay',80); setRange('drive',0.02); setRange('master',0.55);
      setQuant(0.25); setBPM(96);
      applyNow();
    },
    love(){
      setVal('scale','pentatonic'); setVal('root','9'); setVal('osc','triangle');
      setRange('attack',0.06); setRange('release',1.0); setRange('cutoff',2600); setRange('delay',240); setRange('drive',0.08); setRange('master',0.6);
      setQuant(0.125); setBPM(88);
      applyNow();
    },
    angry(){
      setVal('scale','minor'); setVal('root','7'); setVal('osc','sawtooth');
      setRange('attack',0.005); setRange('release',0.18); setRange('cutoff',3800); setRange('delay',60); setRange('drive',0.35); setRange('master',0.7);
      setQuant(0.0625); setBPM(128);
      applyNow();
    }
  };
  function setVal(id,v){ const el=document.getElementById(id); el.value=v; el.dispatchEvent(new Event('input')); }
  function setRange(id,v){ const el=document.getElementById(id); el.value=v; el.dispatchEvent(new Event('input')); }
  function setQuant(v){ document.getElementById('quantize').value=String(v); }
  function setBPM(v){ document.getElementById('bpm').value=v; }
  function applyNow(){ if(!ctx) return; filter.frequency.value=+document.getElementById('cutoff').value; delay.delayTime.value=+document.getElementById('delay').value/1000; master.gain.value=+document.getElementById('master').value; }
  document.querySelectorAll('.preset').forEach(btn=> btn.addEventListener('click', e=>{ const p=e.target.dataset.preset; presets[p](); }));

  // ---------- Export: Audio (WEBM capture) ----------
  function exportAudio(){
    if(!ctx) return;
    if(recorded.length===0){ alert('Nothing recorded. Toggle Compose/Record, type, then try again.'); return; }
    try{
      mediaRec = new MediaRecorder(streamDest.stream);
    }catch(err){ alert('MediaRecorder not supported for audio on this browser. Try Chrome/Edge.'); return; }

    const chunks=[];
    mediaRec.ondataavailable = e=>{ if(e.data.size>0) chunks.push(e.data); };
    mediaRec.onstop = ()=>{
      const blob = new Blob(chunks, {type: 'audio/webm'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='typesynth_capture.webm'; a.click();
      URL.revokeObjectURL(url);
    };

    const dur = startPlayback();
    if(dur<=0){ alert('Nothing to play.'); return; }
    mediaRec.start();
    setTimeout(()=>{ mediaRec.stop(); stopPlayback(); }, Math.max(500, dur+200));
  }

  // ---------- Export: WAV (Offline render) ----------
  async function exportWAV(){
    if(recorded.length===0){ alert('Nothing recorded. Toggle Compose/Record, type, then try again.'); return; }
    const q = parseFloat(document.getElementById('quantize').value);
    const bpm = +document.getElementById('bpm').value;
    const beatMs = 60000/bpm; const baseT = recorded[0].t;

    // Build quantized event list
    const evs = [];
    recorded.forEach(ev=>{
      let at = ev.t - baseT; if(q>0){ const qms=q*beatMs; at = Math.round(at/qms)*qms; }
      evs.push({...ev, at});
    });
    evs.sort((a,b)=> a.at-b.at);
    const lastAt = evs.length? evs[evs.length-1].at : 0;

    const sr = 44100; const tail = 0.6; const duration = Math.ceil((lastAt/1000 + tail)*sr);
    const oc = new OfflineAudioContext(2, duration, sr);

    // build graph (offline)
    const oMaster = oc.createGain(); oMaster.gain.value = +document.getElementById('master').value;
    const oFilter = oc.createBiquadFilter(); oFilter.type='lowpass'; oFilter.frequency.value = +document.getElementById('cutoff').value;
    const oDelay = oc.createDelay(1.0); oDelay.delayTime.value = +document.getElementById('delay').value/1000;
    const oDelayGain = oc.createGain(); oDelayGain.gain.value = 0.22;
    const oDrive = oc.createWaveShaper();
    // small helper for waveshaper curve
    function makeCurve(amount){ const n=1024, c=new Float32Array(n); const k=amount*100+1; for(let i=0;i<n;i++){const x=i*2/n-1; c[i]=(1+k)*x/(1+k*Math.abs(x));} return c; }
    oDrive.curve = makeCurve(+document.getElementById('drive').value);

    oMaster.connect(oc.destination);
    oFilter.connect(oDrive); oDrive.connect(oMaster);
    const oSend = oc.createGain(); oSend.gain.value=0.25; oSend.connect(oDelay); oDelay.connect(oDelayGain); oDelayGain.connect(oFilter);
    const oMix = oc.createGain(); oMix.connect(oFilter);

    // local helpers (offline)
    function oVoice(freq){ const g=oc.createGain(); g.gain.value=0; const o=oc.createOscillator(); o.type=document.getElementById('osc').value; o.frequency.value=freq; o.connect(g); g.connect(oMix); g.connect(oSend); return {o,g}; }
    function oEnvOn(g, t, a, peak){ g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(peak, t+a); }
    function oEnvOff(g, t, r){ g.gain.linearRampToValueAtTime(0.0001, t+r); }
    function oKick(t){ const o=oc.createOscillator(), g=oc.createGain(); o.type='sine'; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(40, t+0.15); g.gain.setValueAtTime(0.9,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2); o.connect(g); g.connect(oFilter); o.start(t); o.stop(t+0.21); }
    function oSnare(t){ const n=oc.createBufferSource(); const b=oc.createBuffer(1, oc.sampleRate*0.2, oc.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length, 2); n.buffer=b; const g=oc.createGain(); g.gain.setValueAtTime(0.6,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); const hp=oc.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200; n.connect(hp); hp.connect(g); g.connect(oFilter); n.start(t); }
    function oHat(t){ const n=oc.createBufferSource(); const b=oc.createBuffer(1, oc.sampleRate*0.05, oc.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; n.buffer=b; const g=oc.createGain(); g.gain.setValueAtTime(0.35,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.05); const hp=oc.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; n.connect(hp); hp.connect(g); g.connect(oFilter); n.start(t); }

    function scheduleLetter(midi, upper, when){
      const atk = +document.getElementById('attack').value; const rel = +document.getElementById('release').value;
      const intensity = 0.7; // normalized for render
      const amp = Math.min(1, 0.2 + intensity*0.8) * (upper? 1.05:1.0);
      const mode = document.getElementById('chordMode').value;
      const trigger = document.getElementById('chordTrigger').value;
      const shouldChord = (mode!=='off') && (trigger==='all' || true); // for offline, treat letters as eligible; vowels handled by caller
      if(mode!=='off'){
        const scaleName = document.getElementById('scale').value; const ivs = chordIntervals(scaleName, mode);
        ivs.forEach((iv,i)=>{ const {o,g}=oVoice(midiToFreq(midi+iv)); o.start(when); oEnvOn(g, when, atk*(upper?1.2:1.0), i? amp*0.66: amp); oEnvOff(g, when, rel*(upper?1.1:1.0)); o.stop(when + Math.max(0.12, rel+0.2)); });
      } else {
        const {o,g}=oVoice(midiToFreq(midi)); o.start(when); oEnvOn(g, when, atk*(upper?1.3:1.0), amp); oEnvOff(g, when, rel*(upper?1.15:1.0)); o.stop(when + Math.max(0.12, rel+0.2));
      }
    }

    evs.forEach(ev=>{
      const t = ev.at/1000; // seconds
      if(/^[a-zA-Z]$/.test(ev.key)){
        const isVowel = vowels.has(ev.key);
        const chordMode = document.getElementById('chordMode').value;
        const trig = document.getElementById('chordTrigger').value;
        const allow = chordMode==='off' || (trig==='all' || isVowel);
        const midi = keyToMidi(ev.key);
        if(allow) scheduleLetter(midi, ev.upper, oc.currentTime + t);
      } else if(['.','!','?'].includes(ev.key)){
        if(ev.key==='.') oKick(oc.currentTime + t);
        else if(ev.key==='!') oSnare(oc.currentTime + t);
        else oHat(oc.currentTime + t);
      } else if(ev.key.startsWith('#')){
        const midi = numberToMidi(parseInt(ev.key.slice(1),10));
        scheduleLetter(midi, false, oc.currentTime + t);
      } else if(ev.key.startsWith('br:')){
        // Optional: light sweep for brackets
        const up = '([{<'.includes(ev.key.slice(3));
        // approximate with filter sweeps
        const f0 = oFilter.frequency.value; oFilter.frequency.setValueAtTime(up? 400 : 1800, oc.currentTime+t); oFilter.frequency.linearRampToValueAtTime(up? 1600: 300, oc.currentTime+t+0.5); oFilter.frequency.setValueAtTime(f0, oc.currentTime+t+0.6);
      }
    });

    const rendered = await oc.startRendering();

    // Convert to WAV (16-bit PCM)
    function bufferToWav(buffer){
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44; // bytes
      const ab = new ArrayBuffer(length);
      const view = new DataView(ab);
      let offset = 0;
      function writeStr(s){ for(let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); }
      function write16(v){ view.setUint16(offset, v, true); offset+=2; }
      function write32(v){ view.setUint32(offset, v, true); offset+=4; }

      writeStr('RIFF'); write32(length-8); writeStr('WAVE');
      writeStr('fmt '); write32(16); write16(1); write16(numOfChan); write32(buffer.sampleRate); write32(buffer.sampleRate*numOfChan*2); write16(numOfChan*2); write16(16);
      writeStr('data'); write32(length-44);

      const channels=[]; for(let i=0;i<numOfChan;i++) channels.push(buffer.getChannelData(i));
      const interleaved = new Float32Array(buffer.length * numOfChan);
      for(let i=0, idx=0;i<buffer.length;i++) for(let ch=0; ch<numOfChan; ch++) interleaved[idx++] = channels[ch][i];
      // clamp & convert
      for(let i=0; i<interleaved.length; i++){ let s = Math.max(-1, Math.min(1, interleaved[i])); view.setInt16(offset, s<0? s*0x8000 : s*0x7FFF, true); offset+=2; }
      return new Blob([ab], {type:'audio/wav'});
    }

    const wav = bufferToWav(rendered);
    const url = URL.createObjectURL(wav);
    const a = document.createElement('a'); a.href=url; a.download='typesynth_offline.wav'; a.click(); URL.revokeObjectURL(url);
  }

  // ---------- Export: MIDI (SMF Type 0) ----------
  function exportMIDI(){
    if(recorded.length===0){ alert('Nothing recorded. Toggle Compose/Record, type, then try again.'); return; }
    const bpm = +document.getElementById('bpm').value; const q = parseFloat(document.getElementById('quantize').value);
    const ppq = 480; // ticks per quarter
    const beatMs = 60000/bpm;
    const baseT = recorded[0].t;

    function vtime(ms){ return Math.round((ms/beatMs)*ppq); }
    function vlq(n){ const bytes=[]; let buffer=n & 0x7F; while((n >>=7)){ buffer <<=8; buffer |= ((n & 0x7F) | 0x80); } while(true){ bytes.push(buffer & 0xFF); if(buffer & 0x80) buffer >>=8; else break; } return bytes; }

    const evs = [];
    recorded.forEach(ev=>{
      let at = ev.t - baseT; if(q>0){ const qms=q*beatMs; at = Math.round(at/qms)*qms; }
      if(/^[a-zA-Z]$/.test(ev.key)){
        const midi = keyToMidi(ev.key);
        // if chord mode, write chord
        const scaleName = document.getElementById('scale').value; const mode = document.getElementById('chordMode').value; const trig=document.getElementById('chordTrigger').value; const isV=vowels.has(ev.key);
        const ivs = (mode==='off' || (trig==='vowels' && !isV))? [0] : chordIntervals(scaleName, mode);
        ivs.forEach((iv,i)=> evs.push({at, on:[0x90, midi+iv, 96-i*12], off:[0x80, midi+iv, 0], len: 160}));
      } else if(['.','!','?'].includes(ev.key)){
        const map = {'.':36,'!':38,'?':42}; const n = map[ev.key];
        evs.push({at, on:[0x99, n, 100], off:[0x89, n, 0], len: 80});
      } else if(ev.key.startsWith('#')){
        const midi = numberToMidi(parseInt(ev.key.slice(1),10));
        evs.push({at, on:[0x90, midi, 90], off:[0x80, midi, 0], len: 220});
      }
    });
    evs.sort((a,b)=> a.at-b.at);

    const track=[]; let lastTick=0;
    const mpq = Math.round(60000000/bpm);
    track.push(...vlq(0), 0xFF, 0x51, 0x03, (mpq>>16)&255, (mpq>>8)&255, mpq&255);

    evs.forEach(e=>{
      const start = vtime(e.at); const deltaOn = start - lastTick; lastTick = start;
      track.push(...vlq(deltaOn), ...e.on);
      const end = vtime(e.at + e.len); const deltaOff = end - lastTick; lastTick = end;
      track.push(...vlq(deltaOff), ...e.off);
    });
    track.push(...vlq(0), 0xFF, 0x2F, 0x00);

    function str2bytes(s){ return [...s].map(c=>c.charCodeAt(0)); }
    const header = [ ...str2bytes('MThd'), 0x00,0x00,0x00,0x06, 0x00,0x00, 0x01,0xE0 ]; // PPQ=480
    const trkHeader = [ ...str2bytes('MTrk')];
    const len = track.length; const lenBytes = [(len>>>24)&255,(len>>>16)&255,(len>>>8)&255,(len)&255];
    const bytes = new Uint8Array([...header, ...trkHeader, ...lenBytes, ...track]);

    const blob = new Blob([bytes], {type:'audio/midi'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='typesynth_track.mid'; a.click(); URL.revokeObjectURL(url);
  }

  // ---------- Wire up UI ----------
  document.getElementById('btnStart').addEventListener('click', ()=>{ initAudio(); setParamLinks(); document.getElementById('text').focus(); });
  document.getElementById('btnClear').addEventListener('click', ()=>{ document.getElementById('text').value=''; recorded.length=0; });
  document.getElementById('btnPlay').addEventListener('click', startPlayback);
  document.getElementById('btnStop').addEventListener('click', stopPlayback);
  document.getElementById('btnExportAudio').addEventListener('click', exportAudio);
  document.getElementById('btnExportMIDI').addEventListener('click', exportMIDI);
  document.getElementById('btnExportWAV').addEventListener('click', exportWAV);

  document.getElementById('text').addEventListener('keydown', (e)=>{
    if((e.ctrlKey||e.metaKey) && ['m','k','p'].includes(e.key.toLowerCase())) e.preventDefault();
  });
  document.getElementById('text').addEventListener('keyup', (e)=>{ if(!ctx) return; handleKey(e); });
})();
</script>
</body>
</html>
